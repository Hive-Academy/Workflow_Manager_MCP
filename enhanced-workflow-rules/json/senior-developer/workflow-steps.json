{
  "workflowSteps": [
    {
      "name": "mandatory_context_consumption_and_setup",
      "displayName": "MANDATORY: Context Consumption and Implementation Setup",
      "description": "Consume existing strategic context and setup implementation environment without re-analysis",
      "sequenceNumber": 1,
      "isRequired": true,
      "estimatedTime": "10-15 minutes",
      "stepType": "ACTION",
      "behavioralContext": {
        "approach": "MANDATORY use mcp operations to get comprehensive task context including codebase analysis, task description, implementation plan, and all subtasks",
        "principles": [
          "WORKFLOW STOPPER: Cannot proceed without consuming existing codebaseAnalysis",
          "NEVER re-investigate comprehensive analysis boomerang already completed",
          "ALWAYS consume architect's strategic guidance completely",
          "ALWAYS retrieve complete implementation plan with all subtasks",
          "ALWAYS build upon previous discoveries rather than starting from scratch"
        ],
        "methodology": "Context consumption with implementation environment preparation and subtask tracking setup",
        "contextConsumption": {
          "codebaseAnalysis": "Extract and validate existing codebaseAnalysis from boomerang (technology stack, patterns, integration points)",
          "strategicGuidance": "Consume architect's strategic guidance (implementation specifics, code examples, quality constraints)",
          "implementationPlan": "Retrieve complete implementation plan with all subtasks and batches",
          "subtaskTracking": "Setup subtask completion tracking for progress monitoring",
          "environmentSetup": "Setup development environment following verified technology stack and patterns",
          "readinessValidation": "Validate implementation readiness without redundant discovery"
        },
        "validationCriteria": {
          "codebaseAnalysisAvailable": "Technology stack, patterns, and integration points from boomerang",
          "strategicGuidanceAvailable": "Implementation specifics, code examples, and quality constraints from architect",
          "implementationPlanAvailable": "Complete plan with all subtasks and strategic guidance",
          "subtaskTrackingReady": "All subtasks identified and ready for completion tracking",
          "implementationReadiness": "No redundant analysis required, existing context comprehensive",
          "contextConsumptionComplete": "Ready to proceed following established patterns"
        },
        "environmentSetup": {
          "gitBranchVerification": "Verify git branch matches task requirements",
          "dependencyInstallation": "Install dependencies using confirmed technology stack",
          "developmentServerValidation": "Validate development server and test functionality",
          "projectStructureConfirmation": "Confirm project structure matches verified analysis"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Execute TaskOperations.get with comprehensive inclusion (plans, subtasks, analysis)",
          "Execute PlanningOperations.get_plan with includeBatches: true to get all subtasks",
          "Extract and validate existing codebaseAnalysis from boomerang (technology stack, patterns, integration points)",
          "Consume architect's strategic guidance (implementation specifics, code examples, quality constraints)",
          "Setup subtask completion tracking for all identified subtasks",
          "Setup development environment following verified technology stack and patterns",
          "Validate implementation readiness without redundant discovery"
        ],
        "contextExtractionSteps": [
          "Call TaskOperations.get with comprehensive parameters to retrieve all context",
          "Call PlanningOperations.get_plan with includeBatches: true to get complete implementation plan",
          "Parse codebaseAnalysis for technology stack, architecture patterns, and integration points",
          "Extract architect's strategic guidance including implementation specifics and code examples",
          "Identify all subtasks that need to be completed before code review delegation",
          "Validate that all necessary context is available for implementation"
        ],
        "environmentSetupSteps": [
          "Verify git branch matches task requirements and is clean",
          "Install dependencies using confirmed technology stack from analysis",
          "Validate development server functionality and test environment",
          "Confirm project structure matches verified analysis patterns"
        ],
        "readinessValidationSteps": [
          "Confirm codebase analysis provides sufficient implementation context",
          "Verify strategic guidance includes specific implementation details",
          "Validate all subtasks are identified and trackable",
          "Validate environment is properly configured for implementation",
          "Ensure no redundant analysis is required to proceed"
        ]
      },
      "qualityChecklist": [
        "Complete task context retrieved including comprehensive analysis and strategic guidance",
        "Complete implementation plan retrieved with all subtasks and batches",
        "Existing codebaseAnalysis consumed (technology stack, architecture, implementation context)",
        "Architect's strategic guidance applied (implementation specifics, code examples, patterns)",
        "All subtasks identified and ready for completion tracking",
        "Development environment configured using verified technology stack",
        "Implementation readiness validated without redundant analysis"
      ],
      "conditions": [],
      "actions": [
        {
          "name": "acquire_comprehensive_context",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "TaskOperations",
            "operation": "get"
          },
          "sequenceOrder": 1
        },
        {
          "name": "acquire_implementation_context",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "PlanningOperations",
            "operation": "get_plan",
            "parameters": {
              "includeBatches": true
            }
          },
          "sequenceOrder": 2
        }
      ],
      "triggerReport": true,
      "reportType": "context_consumption_and_setup",
      "reportTemplate": "mandatory_context_consumption_validation"
    },
    {
      "name": "iterative_subtask_implementation_cycle",
      "displayName": "Iterative Subtask Implementation Cycle",
      "description": "Execute implementation in iterative cycles: get next subtask → implement → test → commit → update status → repeat",
      "sequenceNumber": 2,
      "isRequired": true,
      "estimatedTime": "60-120 minutes",
      "stepType": "ITERATIVE_ACTION",
      "behavioralContext": {
        "approach": "Iterative subtask completion with individual commits and validation after each subtask",
        "principles": [
          "MANDATORY: Get next subtask using SubtaskOperations.get_next_subtask",
          "MANDATORY: Update subtask to 'in-progress' before starting implementation",
          "MANDATORY: Implement following architect's code examples exactly",
          "MANDATORY: Test each subtask implementation thoroughly",
          "MANDATORY: Commit changes after each subtask completion",
          "MANDATORY: Update subtask to 'completed' with evidence after commit",
          "MANDATORY: Repeat cycle until no more subtasks available"
        ],
        "methodology": "Iterative development cycle with individual subtask tracking and commits",
        "iterativeCycle": {
          "getNextSubtask": "Use SubtaskOperations.get_next_subtask to get next available subtask",
          "updateToInProgress": "Update subtask status to 'in-progress' using SubtaskOperations.update_subtask",
          "implement": "Follow architect's strategic guidance and code examples for implementation",
          "test": "Test the specific subtask implementation (unit tests, integration tests, manual validation)",
          "commit": "Commit changes with descriptive message referencing subtask",
          "updateToCompleted": "Update subtask status to 'completed' with completion evidence",
          "repeatCycle": "Continue cycle until SubtaskOperations.get_next_subtask returns no more subtasks"
        },
        "commitStrategy": {
          "commitAfterEachSubtask": "Individual commit for each completed subtask",
          "commitMessageFormat": "feat(subtask): [subtask-name] - [brief description of implementation]",
          "includeSubtaskReference": "Include subtask ID and name in commit message",
          "descriptiveMessages": "Clear description of what was implemented in the subtask"
        },
        "testingPerSubtask": {
          "unitTests": "Test the specific functionality implemented in the subtask",
          "integrationTests": "Test integration points affected by the subtask",
          "manualValidation": "Validate subtask success criteria are met",
          "errorScenarios": "Test error handling for the subtask implementation"
        },
        "solidPrinciples": {
          "singleResponsibility": "Each class/service has one clear purpose and reason to change",
          "openClosed": "Extensible through composition and inheritance, not modification",
          "liskovSubstitution": "Derived classes substitutable for base classes without breaking functionality",
          "interfaceSegregation": "Focused interfaces with specific responsibilities and dependencies",
          "dependencyInversion": "Depend on abstractions and interfaces, not concrete implementations"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Execute SubtaskOperations.get_next_subtask with taskId to get next available subtask",
          "If subtask available: Update status to 'in-progress' using SubtaskOperations.update_subtask",
          "Implement the subtask following architect's strategic guidance and code examples exactly",
          "Test the subtask implementation (unit tests, integration tests, manual validation)",
          "Commit changes with descriptive message referencing the completed subtask",
          "Update subtask status to 'completed' with completion evidence using SubtaskOperations.update_subtask",
          "Repeat from step 1 until SubtaskOperations.get_next_subtask returns no more subtasks"
        ],
        "iterativeCycleSteps": [
          "Call SubtaskOperations.get_next_subtask with taskId parameter",
          "If subtask returned: Call SubtaskOperations.update_subtask with status 'in-progress'",
          "Implement subtask following strategic guidance and SOLID principles",
          "Create and run tests specific to the subtask implementation",
          "Execute git add and git commit with subtask-specific message",
          "Call SubtaskOperations.update_subtask with status 'completed' and completion evidence",
          "Loop back to get next subtask until none available"
        ],
        "implementationSteps": [
          "Follow architect's code examples exactly for the specific subtask",
          "Apply SOLID principles consistently in the subtask implementation",
          "Use established patterns from codebase analysis for consistency",
          "Implement error handling following discovered patterns for the subtask"
        ],
        "testingSteps": [
          "Create unit tests for the specific subtask functionality",
          "Run integration tests for affected components",
          "Perform manual validation of subtask success criteria",
          "Test error scenarios specific to the subtask implementation"
        ],
        "commitSteps": [
          "Stage changes related to the completed subtask using git add",
          "Commit with format: 'feat(subtask): [subtask-name] - [implementation description]'",
          "Include subtask ID and brief description of what was implemented",
          "Verify commit success before updating subtask status"
        ]
      },
      "qualityChecklist": [
        "SubtaskOperations.get_next_subtask used to systematically get each subtask",
        "Each subtask updated to 'in-progress' before implementation starts",
        "Implementation follows architect's strategic guidance and code examples exactly",
        "SOLID principles compliance maintained for each subtask implementation",
        "Testing completed for each subtask (unit, integration, manual validation)",
        "Individual commit made after each subtask completion with descriptive message",
        "Each subtask updated to 'completed' status with proper completion evidence",
        "Cycle continues until SubtaskOperations.get_next_subtask returns no more subtasks"
      ],
      "conditions": [
        {
          "name": "context_consumption_completed",
          "conditionType": "PREVIOUS_STEP_COMPLETED",
          "logic": {
            "check": "step_completed",
            "parameters": {
              "stepName": "mandatory_context_consumption_and_setup"
            }
          },
          "isRequired": true
        }
      ],
      "actions": [],
      "triggerReport": true,
      "reportType": "iterative_subtask_implementation",
      "reportTemplate": "iterative_implementation_cycle_report"
    },
    {
      "name": "final_subtask_completion_validation",
      "displayName": "MANDATORY: Final Subtask Completion Validation",
      "description": "WORKFLOW BLOCKER: Validate ALL subtasks are completed before proceeding to delegation",
      "sequenceNumber": 3,
      "isRequired": true,
      "estimatedTime": "10-15 minutes",
      "stepType": "VALIDATION",
      "behavioralContext": {
        "approach": "MANDATORY final validation - WORKFLOW STOPPER if any subtask remains incomplete",
        "principles": [
          "CRITICAL WORKFLOW BLOCKER: Cannot proceed to delegation without ALL subtasks completed",
          "ALWAYS use PlanningOperations.get_plan with includeBatches: true to get complete subtask status",
          "ALWAYS use SubtaskOperations.get_next_subtask to verify no remaining subtasks",
          "ALWAYS verify each subtask has status 'completed' and proper completion evidence",
          "NEVER allow workflow to proceed if any subtask is not completed",
          "STOP execution immediately if incomplete subtasks are found"
        ],
        "methodology": "Comprehensive final validation with multiple verification methods and workflow blocking",
        "validationProtocol": {
          "primaryValidation": "Use PlanningOperations.get_plan with includeBatches: true to get all subtasks with current status",
          "secondaryValidation": "Use SubtaskOperations.get_next_subtask to confirm no remaining subtasks exist",
          "statusVerification": "Verify every subtask across all batches has status 'completed'",
          "evidenceValidation": "Ensure each completed subtask has proper completion evidence documented",
          "workflowBlocking": "STOP workflow and report error if any subtask is not completed"
        },
        "completionCriteria": {
          "allSubtasksCompleted": "Every subtask in every batch must have status 'completed'",
          "noRemainingSubtasks": "SubtaskOperations.get_next_subtask must return no available subtasks",
          "evidenceDocumented": "Each completed subtask must have completion evidence",
          "batchesCompleted": "All batches must be fully completed",
          "readyForDelegation": "Implementation is complete and ready for delegation"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "MANDATORY: Execute PlanningOperations.get_plan with taskId and includeBatches: true",
          "MANDATORY: Iterate through all batches and verify every subtask has status 'completed'",
          "MANDATORY: Execute SubtaskOperations.get_next_subtask with taskId to confirm no remaining subtasks",
          "MANDATORY: Verify each completed subtask has proper completion evidence",
          "MANDATORY: If ANY subtask is not completed, STOP workflow and report error",
          "MANDATORY: If ALL subtasks are completed, document completion summary for delegation",
          "MANDATORY: Only proceed to next step if 100% subtask completion is verified"
        ],
        "validationSteps": [
          "Call PlanningOperations.get_plan with parameters: { taskId: [TASK_ID], includeBatches: true }",
          "Parse response to extract all subtasks across all batches",
          "For each subtask, verify status === 'completed'",
          "For each completed subtask, verify completion evidence exists",
          "Call SubtaskOperations.get_next_subtask with parameters: { taskId: [TASK_ID] }",
          "Verify response indicates no next subtask available (all completed)"
        ],
        "errorReportingSteps": [
          "If any subtask status !== 'completed', collect all incomplete subtasks",
          "Report specific subtask names, IDs, current status, and batch information",
          "Provide clear remediation steps: complete remaining subtasks before proceeding",
          "STOP workflow execution - do not proceed to next step"
        ]
      },
      "qualityChecklist": [
        "MANDATORY: PlanningOperations.get_plan executed with includeBatches: true to get all subtasks",
        "MANDATORY: Every subtask across ALL batches verified to have status 'completed'",
        "MANDATORY: SubtaskOperations.get_next_subtask confirms no remaining subtasks available",
        "MANDATORY: Each completed subtask has proper completion evidence documented",
        "MANDATORY: If any subtask is incomplete, workflow is STOPPED with clear error message",
        "MANDATORY: 100% subtask completion verified before proceeding to delegation"
      ],
      "conditions": [
        {
          "name": "iterative_implementation_completed",
          "conditionType": "PREVIOUS_STEP_COMPLETED",
          "logic": {
            "check": "step_completed",
            "parameters": {
              "stepName": "iterative_subtask_implementation_cycle"
            }
          },
          "isRequired": true
        }
      ],
      "actions": [
        {
          "name": "validate_all_subtasks_completed",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "PlanningOperations",
            "operation": "get_plan",
            "parameters": {
              "taskId": "[TASK_ID]",
              "includeBatches": true
            }
          },
          "sequenceOrder": 1
        },
        {
          "name": "verify_no_remaining_subtasks",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "SubtaskOperations",
            "operation": "get_next_subtask",
            "parameters": {
              "taskId": "[TASK_ID]"
            }
          },
          "sequenceOrder": 2
        }
      ],
      "triggerReport": true,
      "reportType": "final_subtask_completion_validation",
      "reportTemplate": "final_subtask_validation_report"
    },
    {
      "name": "implementation_completion_and_code_review_delegation",
      "displayName": "Implementation Completion and Code Review Delegation",
      "description": "Complete implementation documentation and delegate to code review with comprehensive implementation evidence",
      "sequenceNumber": 4,
      "isRequired": true,
      "estimatedTime": "10-15 minutes",
      "stepType": "ACTION",
      "behavioralContext": {
        "approach": "Implementation completion with comprehensive delegation context and complete implementation evidence",
        "principles": [
          "Document complete implementation summary with all subtasks completed",
          "Provide comprehensive implementation evidence for code review",
          "Include detailed testing results and quality validation",
          "Delegate to code review with complete context and evidence",
          "Focus on implementation completion, not git operations"
        ],
        "methodology": "Evidence-based delegation with comprehensive implementation documentation",
        "delegationEvidence": {
          "implementationSummary": "Complete summary of all implemented subtasks with details",
          "subtaskCompletion": "Evidence of all subtasks completed with proper status updates",
          "testingResults": "Summary of testing performed for each subtask implementation",
          "qualityValidation": "Confirmation of SOLID principles and pattern compliance",
          "architecturalCompliance": "Evidence of following architect's strategic guidance exactly",
          "codeQuality": "Documentation of code quality standards adherence"
        },
        "delegationContext": {
          "completionEvidence": "Comprehensive evidence that all implementation work is completed",
          "qualityAssurance": "Documentation of quality standards and testing validation",
          "readinessForReview": "Clear indication that implementation is ready for code review",
          "implementationDetails": "Detailed summary of what was implemented and how"
        }
      },
      "approachGuidance": {
        "stepByStep": [
          "Document complete implementation summary including all completed subtasks",
          "Compile comprehensive testing results and quality validation evidence",
          "Prepare implementation evidence showing architectural compliance and SOLID principles",
          "Create detailed delegation context with complete implementation documentation",
          "Execute delegation to code review with comprehensive evidence and context",
          "Include implementation summary, testing results, and quality validation in delegation"
        ],
        "evidencePreparationSteps": [
          "Compile summary of all completed subtasks with implementation details and evidence",
          "Document testing results showing validation for each subtask implementation",
          "Summarize quality validation including SOLID principles and pattern adherence",
          "Confirm architectural compliance with architect's strategic guidance",
          "Prepare comprehensive implementation documentation for code review"
        ],
        "delegationSteps": [
          "Prepare comprehensive delegation context with complete implementation evidence",
          "Execute WorkflowOperations.delegate to code review with detailed context",
          "Include complete implementation summary and quality validation evidence",
          "Provide clear documentation of what was implemented and testing performed"
        ]
      },
      "qualityChecklist": [
        "Complete implementation summary documented with all subtasks and evidence",
        "Comprehensive testing results compiled showing validation for each subtask",
        "Quality validation documented including SOLID principles and architectural compliance",
        "Implementation evidence prepared showing all work completed according to strategic guidance",
        "Delegation context includes comprehensive documentation and quality validation",
        "Code review delegation executed with complete implementation evidence and context"
      ],
      "conditions": [
        {
          "name": "final_validation_completed",
          "conditionType": "PREVIOUS_STEP_COMPLETED",
          "logic": {
            "check": "step_completed",
            "parameters": {
              "stepName": "final_subtask_completion_validation"
            }
          },
          "isRequired": true
        }
      ],
      "actions": [
        {
          "name": "delegate_to_code_review",
          "actionType": "MCP_CALL",
          "actionData": {
            "serviceName": "WorkflowOperations",
            "operation": "delegate"
          },
          "sequenceOrder": 1
        }
      ],
      "triggerReport": true,
      "reportType": "implementation_completion_and_delegation",
      "reportTemplate": "implementation_completion_and_code_review_delegation"
    }
  ]
}
